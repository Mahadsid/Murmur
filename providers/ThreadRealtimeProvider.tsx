import { RealtimeMessage, ThreadEvent, ThreadEventSchema } from "@/app/schemas/realtime";
import { orpc } from "@/lib/orpc";
import { useQueryClient } from "@tanstack/react-query";
import usePartySocket from "partysocket/react";
import { createContext, ReactNode, useContext, useMemo } from "react";

interface ThreadRealtimeProviderProps {
    threadId: string;
    children: ReactNode;
}
type ThreadRealtimeContextValue = {
    send: (event: ThreadEvent) => void;
}
const ThreadRealtimeContext = createContext<null | ThreadRealtimeContextValue>(null);

export function ThreadRealtimeProvider({ threadId, children }: ThreadRealtimeProviderProps) {
    const queryClient = useQueryClient();

    type ThreadListOptions = ReturnType<typeof orpc.message.thread.list.queryOptions>;
    type ThreadQueryData = Awaited<ReturnType<ThreadListOptions["queryFn"]>>;

    const socket = usePartySocket({
        host: "https://murmur-realtime.muhammadmahad6.workers.dev",
        room: `thread-${threadId}`,
        party: "chat",

        onMessage(e) {
            try {
                const parsed = JSON.parse(e.data);
                const result = ThreadEventSchema.safeParse(parsed);
                if (!result.success) {
                    console.warn("Invalid channel event")
                    return;
                }

                //get event
                const event = result.data
                //check what type of event and code accordingly
                if (event.type === "thread:reply:created") {

                    const replyObj = event.payload.reply as RealtimeMessage
                    //use the same key generated by orpc
                    const listOptions = orpc.message.thread.list.queryOptions({
                        input: { messageId: threadId },
                    });
                    queryClient.setQueryData<ThreadQueryData>(
                        listOptions.queryKey,
                        (old) => {
                            if (!old) {
                                return old;
                            }
                            const reply = {
                                reactions: Array.isArray(replyObj.reactions) ? replyObj.reactions : [],
                                ...replyObj,
                            } as ThreadQueryData['messages'][number]
                            return {
                                ...old,
                                messages: [...old.messages, reply],
                            }
                        }
                    );
                    return;
                }

                // if (event.type === 'thread:reaction:updated') {
                //     const { messageId, reactions, threadId: tid } = event.payload

                //     if (tid !== threadId) {
                //         //thread do not match, we got threadId from Props also so we change this payload threadId to tis.
                //         return;
                //     }

                //     //use the same key generated by orpc
                //     const listOptions = orpc.message.thread.list.queryOptions({
                //         input: { messageId: threadId },
                //     });

                //     queryClient.setQueryData(listOptions.queryKey, (old) => {
                //         if (!old) {
                //             return old;
                //         }
                //         if (messageId === threadId) {
                //             return {
                //                 ...old,
                //                 parent: {
                //                     ...old.parent,
                //                     reactions
                //                 }
                //             }
                //         }
                //         return {
                //             ...old,
                //             messages: old.messages.map((m) => m.id === messageId ? { ...m, reactions } : m),
                //         }
                //     });
                //     return;
                // }
                if (event.type === "thread:reaction:updated") {
                    const { messageId, reactions: serverReactions, threadId: tid } = event.payload;

                    if (tid !== threadId) return;

                    const listOptions = orpc.message.thread.list.queryOptions({
                        input: { messageId: threadId },
                    });

                    queryClient.setQueryData<ThreadQueryData>(
                        listOptions.queryKey,
                        (old) => {
                            if (!old) return old;

                            const merge = (
                                local: typeof serverReactions | undefined
                            ) => {
                                const localRxns = local ?? [];

                                return serverReactions.map((srv) => {
                                    const found = localRxns.find((l) => l.emoji === srv.emoji);
                                    return {
                                        emoji: srv.emoji,
                                        count: srv.count,
                                        reactedByMe: found?.reactedByMe ?? false,
                                    };
                                });
                            };

                            // Parent message reaction update
                            if (messageId === threadId) {
                                return {
                                    ...old,
                                    parent: {
                                        ...old.parent,
                                        reactions: merge(old.parent.reactions),
                                    },
                                };
                            }

                            // Reply reaction update
                            return {
                                ...old,
                                messages: old.messages.map((m) =>
                                    m.id === messageId
                                        ? { ...m, reactions: merge(m.reactions) }
                                        : m
                                ),
                            };
                        }
                    );
                }


            } catch {
                console.log("Something went wrong")
            }
        }

    });
    const value = useMemo<ThreadRealtimeContextValue>(() => {
        return {
            send: (event) => {
                socket.send(JSON.stringify(event));
            }
        }
    }, [socket]);

    return (
        <ThreadRealtimeContext.Provider value={value}>
            {children}
        </ThreadRealtimeContext.Provider>
    )
}

export function useThreadRealtime() {
    const ctx = useContext(ThreadRealtimeContext);
    if (!ctx) {
        throw new Error(
            "useThreadRealtime must be used within a ThreadrealtimeProvider"
        );
    }
    return ctx;
}
export function useOptionalThreadRealtime(): ThreadRealtimeContextValue | null {
    return useContext(ThreadRealtimeContext);
}

